#!/bin/bash
#
# droid-discord - Discord-Droid Bridge CLI
# Session management and status commands
#

set -uo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Source library files
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/registry.sh"

usage() {
    cat <<EOF
Discord-Droid Bridge CLI (V2 - iTerm2 only)

Usage: droid-discord <command> [args]

Session Commands:
  register <threadId> [name]  Register current session with Discord thread
  deregister [threadId]       Deregister session
  status                      Show current session status
  list                        List all registered sessions

Bridge Commands:
  start                       Start the bridge daemon (foreground)
  start-bg                    Start the bridge daemon (background)
  stop                        Stop the bridge daemon
  logs                        Show bridge logs
  cleanup                     Remove sessions with dead PIDs
  send <threadId> [message]   Send a message to a Discord thread (stdin if omitted)

Examples:
  droid-discord register 1234567890123456789 "[myproject:main]"
  droid-discord start-bg
  droid-discord status
  droid-discord send 1234567890123456789 "Hello from Droid"
EOF
}

get_discord_token() {
    if [[ -n "${DISCORD_TOKEN:-}" ]]; then
        echo "$DISCORD_TOKEN"
        return 0
    fi

    if [[ -f "$HOME/.factory/mcp.json" ]]; then
        jq -r '.mcpServers.discord.env.DISCORD_TOKEN // empty' "$HOME/.factory/mcp.json"
        return 0
    fi

    echo ""
}

# Normalize token (trim whitespace, remove accidental "Bot " prefix)
normalize_discord_token() {
    local token="$1"
    # Trim whitespace
    token="${token#"${token%%[![:space:]]*}"}"
    token="${token%"${token##*[![:space:]]}"}"
    # Remove "Bot " prefix if present (case-insensitive)
    if [[ "${token,,}" == bot\ * ]]; then
        token="${token:4}"
    fi
    printf '%s' "$token"
}

# Simplified text chunking for Discord's 2000 char limit
chunk_text() {
    local text="$1"
    local limit="$2"
    CHUNKS=()

    [[ -z "$text" ]] && return 0
    
    while (( ${#text} > limit )); do
        local chunk="${text:0:limit}"
        # Try to break at whitespace using parameter expansion
        if [[ "$chunk" =~ ^(.*[[:space:]])[^[:space:]]*$ ]]; then
            chunk="${BASH_REMATCH[1]}"
        fi
        # Trim trailing whitespace
        chunk="${chunk%"${chunk##*[![:space:]]}"}"
        [[ -n "$chunk" ]] && CHUNKS+=("$chunk")
        # Remove chunk from text and trim leading whitespace
        text="${text:${#chunk}}"
        text="${text#"${text%%[![:space:]]*}"}"
    done
    
    [[ -n "$text" ]] && CHUNKS+=("$text")
}

send_discord_message() {
    local thread_id="$1"
    local message="$2"
    local token
    token=$(get_discord_token)

    if [[ -z "$token" ]]; then
        echo "Error: DISCORD_TOKEN not found (set env or ~/.factory/mcp.json)" >&2
        return 1
    fi

    # Validate thread ID format
    if ! [[ "$thread_id" =~ ^[0-9]{17,20}$ ]]; then
        echo "Error: Invalid thread ID format" >&2
        return 1
    fi

    token="$(normalize_discord_token "$token")"

    # Discord message limit is 2000 chars
    local max_len=2000

    # Create secure temp file for auth header (prevents token exposure in ps output)
    local header_file
    header_file=$(secure_temp)
    printf 'Authorization: Bot %s' "$token" > "$header_file"
    chmod 600 "$header_file"
    
    # Ensure cleanup on exit
    trap 'rm -f "$header_file" 2>/dev/null' RETURN

    chunk_text "$message" "$max_len"
    local chunk
    for chunk in "${CHUNKS[@]}"; do
        local payload
        payload=$(printf '%s' "$chunk" | jq -Rs '{content: .}')

        curl -sS -X POST \
            -H @"$header_file" \
            -H "Content-Type: application/json" \
            -d "$payload" \
            "https://discord.com/api/v10/channels/$thread_id/messages" >/dev/null || return 1
        sleep 0.2
    done
    
    rm -f "$header_file"
}

cmd_register() {
    local thread_id="${1:-}"
    local thread_name="${2:-}"
    
    if [[ -z "$thread_id" ]]; then
        echo "Usage: droid-discord register <threadId> [name]"
        exit 1
    fi
    
    # Validate thread ID format before any file operations
    if ! [[ "$thread_id" =~ ^[0-9]{17,20}$ ]]; then
        echo "Error: Thread ID must be 17-20 digits" >&2
        exit 1
    fi
    
    register_session "$thread_id" "$thread_name"
    
    # Save current session for cleanup on exit
    echo "$thread_id" > "$HOME/.factory/current-discord-session"
    
    echo ""
    echo "Export thread ID: export DROID_THREAD_ID=$thread_id"
}

cmd_deregister() {
    local thread_id="${1:-${DROID_THREAD_ID:-}}"
    
    if [[ -z "$thread_id" ]]; then
        echo "No thread ID provided and DROID_THREAD_ID not set"
        exit 1
    fi
    
    deregister_session "$thread_id"
}

cmd_status() {
    show_session_status
}

cmd_list() {
    list_sessions
}

cmd_cleanup() {
    cleanup_dead_sessions
}

cmd_start() {
    exec "$SCRIPT_DIR/bridge-v2.sh"
}

cmd_start_bg() {
    if pgrep -f "bridge-v2.sh" > /dev/null; then
        echo "Bridge is already running"
        exit 1
    fi
    
    nohup "$SCRIPT_DIR/bridge-v2.sh" >> "$LOG_FILE" 2>&1 &
    echo "Bridge started (PID: $!)"
    echo "Logs: $LOG_FILE"
}

cmd_stop() {
    if ! pgrep -f "bridge-v2.sh" > /dev/null; then
        echo "Bridge is not running"
        exit 0
    fi
    
    pkill -f "bridge-v2.sh"
    pkill -f "fswatch.*discord-inbox"
    echo "Bridge stopped"
}

cmd_logs() {
    if [[ -f "$LOG_FILE" ]]; then
        tail -50 "$LOG_FILE"
    else
        echo "No log file at $LOG_FILE"
    fi
}

cmd_send() {
    local thread_id="$1"
    shift || true

    if [[ -z "$thread_id" ]]; then
        echo "Usage: droid-discord send <threadId> [message]"
        exit 1
    fi

    local message="$*"
    if [[ -z "$message" ]]; then
        message=$(cat)
    fi

    if [[ -z "$message" ]]; then
        echo "Error: message is empty" >&2
        exit 1
    fi

    send_discord_message "$thread_id" "$message"
}

case "${1:-}" in
    register)    shift; cmd_register "$@" ;;
    deregister)  shift; cmd_deregister "$@" ;;
    status)      cmd_status ;;
    list)        cmd_list ;;
    cleanup)     cmd_cleanup ;;
    start)       cmd_start ;;
    start-bg)    cmd_start_bg ;;
    stop)        cmd_stop ;;
    logs)        cmd_logs ;;
    send)        shift; cmd_send "$@" ;;
    -h|--help|help|"") usage ;;
    *)           echo "Unknown: $1"; usage; exit 1 ;;
esac
